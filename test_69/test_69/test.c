#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
//操作符详解

//int main()
//{
//
//	//int a = 3 / 5;  //0.6
//	//printf("%d", a); //0
//	//float a = 6 / 5;
//	//printf("%f", a);  //1.00000
//
//	float a = 6 / 5.0;
//	printf("%f", a);   //1.20000
//
//	return 0;
//}


//int main()
//{
//	int a = 7 % 3;   //模(%)操作符两边必须是整数
//	printf("%d", a);  //1
//	return 0;
//}

//-----------------------移位操作符-------------------------

//int main()
//{
//	int a = 2;
//	//把a的二进制位向左移动一位
//	int b = a << 1;
//	printf("%d\n", a);
//	printf("%d\n", b);
//
//	return 0;
//}

//int main()
//{
//	int a = 10;
//	//把a的二进制位向右移动一位
//	int b = a >> 1;
//	printf("%d\n", a);
//	printf("%d\n", b);
//
//	return 0;
//}

//int main()
//{
//	int a = -1;
//	//把a的二进制位向右移动一位
//	int b = a >> 1;
//	printf("%d\n", a);
//	printf("%d\n", b);  //-1 说明是算数右移
//
//	return 0;
//}

//左移操作符---左边丢弃，右边补0
//右移操作符
//1.算数右移  ---  右边丢弃，左边补原符号位
//2.逻辑右移  ---  右边丢弃，左边补0


//-------------------------位操作符-----------------------------
//操作对象必须是整数
// 
//int main()
//{
//	int a = 3;
//	int b = 5;
//	////&  -  按(二进制)位与
//	////
//	//int c = a & b;
//	//printf("%d", c);  //1
//	////000000000000000000000000000000011
//	////000000000000000000000000000000101
//	////按位与的结果
//	////000000000000000000000000000000001
//
//	//  |   按(二进制)位或
//	//int c = a | b;
//	////000000000000000000000000000000011
//	////000000000000000000000000000000101
//	////按位或的结果
//	////000000000000000000000000000000111
//	//printf("%d", c); //7
//
//	//  ^  按位(二进制位)异或
//	//对应二进制位进行异或
//	//对应二进制位相同为0，相异为1
//	int c = a ^ b;
//	//000000000000000000000000000000011
//	//000000000000000000000000000000101
//	//按位异或的结果
//	//000000000000000000000000000000110
//	printf("%d", c); //6
//	return 0;
//}

//应用场景
//不创建第三个变量交换两个变量
//int main()
//{
//	int a = 3;
//	int b = 5;
//	//交换
//	//printf("a = %d  b = %d\n", a, b);
//	//a = a + b;
//	//b = a - b;
//	//a = a - b;  //数字太大会溢出
//	//printf("a = %d  b = %d\n", a, b);
//	//异或完成
//	printf("a = %d  b = %d\n", a, b);
//	a = a ^ b;
//	b = a ^ b;
//	a = a ^ b;  //数字太大会溢出
//	printf("a = %d  b = %d\n", a, b);
//
//	return 0;
//}



//编写代码；求一个整数存储在内存中的二进制中1的个数
//int main()
//{
//	int a = 13;
//	//把二进制中第5位变成1
//	a = a | (1 << 4);
//	a = a & ~(1 << 4);
//	printf("%d\n", a);
//	//00000000000000000000000000001101
//	//00000000000000000000000000000001
//	//00000000000000000000000000011101
//
//	return 0;
//}




//赋值操作符
//=  +=   -=   /=  >>=  %=等

//单目操作符   ----   只有一个操作数
//  ! 逻辑反
//  - 负值
//  + 正值
//  & 取地址
//  sizeof  操作数的类型长度(以字节为单位)
//  ~  对一个数的二进制按位取反
//  --  前置、后置减减
//  ++  前置、后置加加
//  *   简介访问操作符
// (类型)   强制类型转换
//


//int main()
//{
//	int a = 10;
//	//a = -a;
//	printf("%d", a);
//	return 0;
//}
 
//int main()
//{
//	short s = 5;
//	int a = 10;
//	//sizeof 中放的表达式,不参与运算
//	printf("%d\n", sizeof(s = a + 2));  //2
//	printf("%d\n", s);					//5
//	//int a = 10;
//	//int arr[10] = { 0 };
//	//printf("%zd\n", sizeof(a));   //4
//	//printf("%zd\n", sizeof(int));
//	////sizeof 是操作符,不是函数
//	//printf("%zd\n", sizeof a);  //4
//	//printf("%d\n", sizeof(arr));  //单位是字节  40
//	//printf("%d\n", sizeof(int[10]));  //40  -  int [10]是arr数组的类型
// 	return 0;
//}

//int main()
//{
//	int a = -1;
//	//10000000000000000000000000000001   --  原码
//	//11111111111111111111111111111110   --  反码
//	//11111111111111111111111111111111   --  补码
//	//~按位取反
//	int b = ~a;
//	//11111111111111111111111111111111
//	//~
//	//00000000000000000000000000000000
//	printf("b = %d\n", b);
//	printf("a = %d\n", a);
//
//	return 0;
//}


//----------------------------------------------------------------------!!!!!!

//int main()
//{
//	int a = 10;
//	printf("%p\n",&a); //取地址操作符,
//	//打印出来的是a所在内存单元的起始地址编号
//	int *pa = &a;//pa用来存放地址的,---pa就是指针变量
//	*pa = 20;  //* - 解引用操作符 - 间接访问操作符
//	printf("%d\n", a);
//	return 0;
//}



//int main()
//{
//	int a = (int)3.14; // 强制类型转换
//	
//	return 0;
//}

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//int main()
//{
//    int i = 0, a = 0, b = 2, c = 3, d = 4;
//    //对于&&操作符,如果左边为0后边的不会再进行计算
//    //i = a++ && ++b && d++;  //a-d=1,2,3,4
//    //对于||操作符,如果左边为真后边不会再进行计算
//    i = a++||++b||d++;    //1,3,3,4
//    printf("a = %d\nb = %d\nc = %d\nd = %d\n", a, b, c, d);
//    return 0;
//}
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

//三目操作符  表达式1 ? 表达式2   :表达式3

//int main()
//{
//	int a = 3;
//	int b = 0;
//	//if (a>5)
//	//{
//	//	b = 1;
//	//}
//	//else
//	//{
//	//	b = -1;
//	//}
//
//	//三目操作符实现
//	b = (a > 5 ? 1 : -1);
//	printf("%d\n", b);
//
//	return 0;
//}

//------------------  逗号表达式  ----------------------------
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = 0;
//	//逗号表达式,从左往右依次执行,输出最后一个表达式的值
//	int d = (c = 5, a = c + 3, b = a - 4, c += 4);  //9
//	printf("%d\n", d);
//	return 0;
//}

//----------------------------------------------------------------
//下标引用操作符[]

//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	printf("%d", arr[4]);
//	//[]的操作数是:arr   ,   4
//	return 0;
//}

//函数调用操作符

//函数的定义
//int Add(int x, int y)
//{
//	return x + y;
//}
//
//void test()
//{
//
//}
//int main()
//{
//	int a = 10;
//	int b = 20;
//	//函数调用
//	test();
//	int ret = Add(a, b);  // () - 函数调用操作符
//	printf("%d\n", ret);
//	return 0;
//}

//!!!!!!!!!!!!!!!!!!!!!!!-----------!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//结构成员访问操作符
//.    利用此操作符,找出struct的结构体成员
//->

//结构体  --  自定义类型
//
//书:书名,书号,定价
//人:名字,年龄,性别
//

//创建了一个自定义的类型
//struct Book
//{
//	char name[20];
//	char id[20];
//	int price;
//};

//int main()
//{
//	struct Book b = { "c语言","c2022054",120 };
//	struct Book *pb = &b;
//
//	//结构体指针->成员名
//	printf("书名:%s\n", pb->name);
//	printf("书号:%s\n", pb->id);
//	printf("定价:%d\n", pb->price);
//
//	//printf("书名:%s\n", (*pb).name);
//	//printf("书号:%s\n", (*pb).id);
//	//printf("定价:%d\n", (*pb).price);
//
//
//
//	//结构体变量名.成员名
//	//printf("书名:%s\n", b.name);
//	//printf("书号:%s\n", b.id);
//	//printf("定价:%d\n", b.price);
//
//	return 0;
//}

//表达式求值
//表达式求值的顺序一部分是由操作符的优先级和结合性决定
//

//整型提升
//C的整型算术运算总是至少以缺省整型类型的精度来进行的。
//为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型
//提升。
//整型提升的意义：
//表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度
//一般就是int的字节长度，同时也是CPU的通用寄存器的长度。
//因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长
//度。
//通用CPU（general - purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令
//中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转
//换为int或unsigned int，然后才能送入CPU去执行运算。

//无符号整型提升,高位补0
//int main()
//{
//	char a = 3;
//	char b = 127;
//	char c = a + b;  //-126
//
//	//发现a,b都是char类型,都没有达到一个int的大小
//	//这里就会发生整型提升
//	
//	printf("%d\n", c);
//	return 0;
//}

//实例1
//int main()
//{
//	char a = 0xb6;
//	short b = 0xb600;
//	int c = 0xb6000000;
//	if (a == 0xb6)
//		printf("a");
//	if (b == 0xb600)
//		printf("b");
//	if (c == 0xb6000000)
//		printf("c");
//	return 0;
//}


// 实例2
//int main()
//{
//	char c = 1;
//	//%u 打印无符号整型  %d 打印有符号整型
//	printf("%u\n", sizeof(c));  //1
//	printf("%u\n", sizeof(+c)); //4
//	printf("%u\n", sizeof(-c)); //4
//	printf("%u\n", sizeof(!c)); //结果应该是4   gcc情况下是4
//
//	return 0;
//}

//!!!!!整型大小发生情况,自身大小达不到整型大小,就会发生整型提升!!!!!!!!
//---------------------------------------------------------------------

//算数转换


//------------------------

//int main()
//{
//	int a = 4;
//	int b = 5;
//	int c = a + b * 7;//优先级决定计算顺序
//	int c = a + b + 7;// 优先级不起作用,结合性决定顺序 L-R
//
//	return 0;
//}



//------------------------------习题------------------------------------
#include <string.h>
//int main()
//{
//	char str[] = "hello bit";
//	printf("%d  %d\n", sizeof(str), strlen(str));   //10   9
//	//strlen - 函数 - 求字符串长度,找\0之前出现的字符个数
//	//sizeof - 操作符 - 计算变量/类型所占内存大小,单位是字节
//	return 0;
//}

//实现函数init()初始化数组为全0
//实现print()打印数组的每个元素
//实现reverse()函数完成数组元素的逆置

//void init(int arr[],int len)
//{
//	int i = 0;
//	for (i = 0; i < len; i++)
//	{
//		arr[i] = 0;
//	}
//	
// }
//void print(int arr[],int len)
//{
//	int i = 0;
//	for ( i = 0; i < len; i++)
//	{
//		printf("%d \n", arr[i]);
//	}
//}
//void reverse(int arr[], int len)
//{
//	int left = 0;
//	int right = len - 1;
//	while (left<right)
//	{
//		int tmp = arr[left];
//		arr[left] = arr[right];
//		arr[right] = tmp;
//		left++;
//		right--;
//	
//	}
//}
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//
//	print(arr, sz);
//	//init(arr,sz);
//	printf("--------------------------------------------\n");
//	reverse(arr, sz);
//	print(arr, sz);
//	return 0;
//}



//交换两个数组中的内容  (数组一样大)

void swap(int x[], int y[], int len)
{
	int i = 0;
	for ( i = 0; i < len; i++)
	{
		int tmp = x[i];
		x[i] = y[i];
		y[i] = tmp;
	}
}

int main()
{
	int arr1[4] = { 1,1,1,1 };
	int arr2[4] = { 2,2,2,2 };
	int sz = sizeof(arr1) / sizeof(arr1[0]);
	swap(arr1, arr2, sz);
	printf("%d\n", arr1[0]);
	printf("%d", arr2[0]);

}
























































